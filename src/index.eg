
require:
   quasar ->
      cached-function, State, Function
   "./fs" ->
      FileIterator, FileSystem
   .output ->
      Write, Delete, commit-all
   .util ->
      rename, Renamer
      task-function
      Logger, EngageMessage
   lodash
   path
   chalk
   fs
   filendir

provide:
   cached-function
   task-function
   FileIterator, FileSystem
   Logger, EngageMessage, log, minilog
   rename, Renamer
   Write, Delete, commit-all
   Engage
   task
   each!


debounce{delay}{f} =
   lodash.debounce{f, delay}


log = Logger{}
minilog = Logger{false}

defaults = {
   debounce = 25
   log = log
   error = console.error
}


TOP = "{{TOP}}"
meta-task{main-task} =
   method f{} =
      if @root-path:
         main-task{@get{@root-path}}
      else:
         main-task{null}
   f.engage-name = TOP
   cached-function{f}


default-show = {
   task = true
   cache = false
   read = true
   write = true
}

class Engage:

   constructor{main-task, @options = {=}} =
      @main-task = meta-task{main-task}
      @options = defaults & @options
      @options.show = default-show & [@options.show or {=}]
      @last-effects = new Set{}
      @file-contents = {=}

   run{} =
      @state = State{FileSystem{@options}, commit-policy = null}
      @state.on{.transact, lodash.debounce{f, @options.debounce}} where f{} =
         @state.commit{}
      @reac = Function{@state, @main-task} with {
         listeners = {
            effect{match eff} =
               #write{path, contents} ->
                  match @file-contents[path]:
                     undefined? ->
                        if @options.show.write:
                           @options.log??{EngageMessage{.add-file, path}}
                     === contents ->
                        return
                     else ->
                        if @options.show.write:
                           @options.log??{EngageMessage{.change-file, path}}
                  filendir.write-file-sync{path, contents}
                  @file-contents[path] = contents
            start-compute{f, s, args} =
               if f.engage-name !== TOP and @options.show.task:
                  @options.log??{EngageMessage{.begin, f.engage-name, args}}
            end-compute{f, s, args, time} =
               if f.engage-name !== TOP and @options.show.task:
                  @options.log??{EngageMessage{.end, f.engage-name, args, time}}
            begin-cache{f, s, args} =
               if f.engage-name !== TOP and @options.show.task and @options.show.cache:
                  @options.log??{EngageMessage{.begin-cache, f.engage-name, args}}
            end-cache{f, s, args} =
               if f.engage-name !== TOP and @options.show.task and @options.show.cache:
                  @options.log??{EngageMessage{.end-cache, f.engage-name, args}}
            read-file{path} =
               if @options.show.read:
                  @options.log??{EngageMessage{.read-file, path}}
         }
         clobber-patch = false
      }
      @reac.on{.error, e -> @err{e}}
      @reac.sync{-> @act{}}
      @reac.sync-effects{e -> @effects{e}}

   async act{} =
      v = await @reac.get{} ;; ???
      commit-all{v, @options}

   async effects{new-effects >> [new Set{new-effects}]} =
      pass
      ;; ;; print #A{new-effects}
      ;; ;; print #B{@last-effects}
      ;; new-effects each effect ->
      ;;    if not @last-effects.has{effect}:
      ;;       @options.log{EngageMessage{.add-file, effect}}
      ;; if @options.clean:
      ;;    @last-effects each effect ->
      ;;       if not new-effects.has{effect}:
      ;;          fs.unlink-sync{effect}
      ;;          @options.log{EngageMessage{.remove-file, effect}}
      ;; @last-effects = new-effects

   async err{e} =
      @options.error{"An error occurred."}
      @options.error{e.stack}


globals: exports
exports and module.exports = Engage


macro{task-function} task-macro{expr} =
   let {"task-function" => tfn} = @deps
   {it, self} = @mark{`@`, `self`}
   expr as [#send{#symbol{name}, _} or name is ""]
   @multimacro with {
      project{match expr} =
         `_lambda{^args, ^pre, ^body, ^post, ^gen}` ->
            ```
            [^tfn]{^=name} with eager-async with
               _lambda{^args, ^pre, [let ^it and ^self = this, ^body], ^post, ^gen}
            ```
         `^args -> ^body` ->
            ```
            [^tfn]{^=name} with eager-async with
               ^args ->
                  let ^it and ^self = this
                  ^body
            ```
         else ->
            ;; print expr
            throw E.syntax.invalid-task{"invalid", node = expr}
   }

task = task-function
task.macro = task-macro

macro{task-function} [each!]{#data{expr, body}} =
   let {"task-function" => tfn} = @deps
   ```
   eager-async rawf{x} = match x: ^body
   f = [^tfn]{rawf}
   ^expr each x -> await f{x}
   ```

