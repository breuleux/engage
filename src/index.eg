
require:
   quasar ->
      cached-function, State, Function
   .directory ->
      FileIterator, FileSystem, Directory
   .file ->
      File
   .output ->
      Write, Delete, commit-all
   .util ->
      rename, Renamer
      task-function
   lodash
   path

provide:
   cached-function
   task-function
   FileIterator, FileSystem, Directory, File
   rename, Renamer
   Write, Delete, commit-all
   Engage
   task
   each!


debounce{delay}{f} =
   lodash.debounce{f, delay}


class Engage:
   constructor{@main-task, @options = {=}} =
      @options.debounce or= 25
      @options.log or= console.log
      @options.error or= console.error
      @options.rename or= Renamer{@options}
   run{} =
      @state = State{FileSystem{@options}, input-self = true, commit-policy = null}
      @state.on{.transact, lodash.debounce{f, @options.debounce}} where f{} =
         @state.commit{}
      @reac = Function{@state, @main-task, {clobber-patch = false}}
      ;; @act{}
      @reac.sync{-> @act{}}
   async act{} =
      results = await @reac.get{}
      commit-all{results, @options}

globals: exports
exports and module.exports = Engage


macro{task-function} task-macro{expr} =
   let {"task-function" => tfn} = @deps
   {system, it, self} = @mark{`system`, `@`, `self`}
   @multimacro with {
      project{match expr} =
         `_lambda{^args, ^pre, ^body, ^post, ^gen}` ->
            ```
            [^tfn] with eager-async with
               _lambda{^args, ^pre, [let ^it and ^self = this, ^body], ^post, ^gen}
            ```
         `^args -> ^body` ->
            ```
            [^tfn] with eager-async with
               ^args ->
                  let ^it and ^self = this
                  ^body
            ```
         else ->
            print expr
            throw E.syntax.invalid-task{"invalid", node = expr}
   }

task = task-function
task.macro = task-macro

macro{task-function} [each!]{#data{expr, body}} =
   let {"task-function" => tfn} = @deps
   ```
   eager-async rawf{x} = match x: ^body
   f = [^tfn]{rawf}
   await all [^expr each x -> f{x}]
   ```

