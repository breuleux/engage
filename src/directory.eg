
require:
   spacecore2 ->
      ID, DIRECTORY
      methods, fields
      setup-proxy, deprox, proxy
      current-context
   path
   fs
   .file ->
      File
   .util ->
      Renamer, task-function
   .output ->
      Write
   chokidar
   minimatch

provide:
   FileIterator
   FileSystem
   Directory



extract-text-transformer{f} =
   method new-f{File? file, options} =
      state = current-context{}??.state
      if not state:
         throw E.map-file{"Cannot find a renaming function to use."}
      res = f.call{@, file.text, file}
      match res:
         Write? w -> w
         String? s ->
            Write{state.self{}.rename{file.path, options}, s}
         other ->
            other
   new-f

class FileIterator:
   constructor{@gen} =
      @results = null
   gen [^Symbol.iterator]{} =
      if @results:
         @results each x -> yield x
      else:
         results = {}
         @gen each x ->
            results.push{x}
            yield x
         @results = results
   map{fn} =
      t = task-function{fn}
      [@] each x -> t{x}
   map-file{options = {=}, fn} =
      t = task-function{fn, extract-text-transformer}
      [@] each file -> t{file, {=} & options}
   bundle{fn} =
      throw E.todo{}

analyze-path{p >> p.split{"/"}} =
   var i = 0
   if p.length > 1 and p[0] === "":
      p[0] = "/"
   p[.. -1] each part ->
      if R"*"? part: break
      i += 1
   {base = p.slice{0, i}
    rest = p.slice{i}}

class FileSystem:

   constructor{@options} =
      [@] &: @options
      @directory-cache = {=}

   get{p} =
      match @directory-cache[p]:
         undefined? ->
            stat = fs.lstat-sync{p}
            entry =
               if stat.is-directory{}:
                  Directory{p}
               else:
                  File{p}
            expr-value @directory-cache[p] =
               match @[DIRECTORY]:
                  undefined? ->
                     entry
                  dir ->
                     dir.acquire{entry}
         existing ->
            existing

   find{glob} =
      {=> base, => rest} = analyze-path{glob}
      @get{base}.find{rest.join{"/"}}

   [^methods.proxy]{tracks, patch, prevent-dirty-reads} =
      FileSystemProxy{@, tracks, patch, prevent-dirty-reads}


class FileSystemProxy < FileSystem:

   constructor{obj, tracks, patch, prevent-dirty-reads = true} =
      [@] &: obj.options
      setup-proxy{@, obj, tracks, patch, prevent-dirty-reads}

   _prox{x} =
      proxy{x, @[fields.tracks], @[fields.patch], @[fields.prevent-dirty-reads]}

   get{key} =
      @[methods.check-dirty-read]{key}
      @[methods.register-tracks]{key, -> true}
      @_prox{@[fields.obj].get{key}}
      


class Directory:

   type = .directory

   constructor{@path} =
      @data = Object.create{null}
      fs.readdir-sync{@path} each filename ->
         stat = fs.lstat-sync with path.join{@path, filename}
         @data[filename] =
            if stat.is-directory{}:
               .directory
            elif stat.is-file{}:
               .file
            else:
               .unsupported

   find{glob} =
      gen g{} =
         match glob.split{"/"}:
            {""} ->
               yield [@]
            {"**", *rest} ->
               yield all @find{rest.join{"/"}}
               [@] each entry when entry.find ->
                  yield all entry.find{glob}
            {minimatch.make-re! x, *rest} ->
               @keys{} each
                  x? name ->
                     entry = @get{name}
                     if rest == {}:
                        yield entry
                     elif entry.type === "directory":
                        yield all entry.find{rest.join{"/"}}
                  else ->
                     continue
      FileIterator{g{}}

   get{key} =
      match key.split{"/"}:
         {file} ->
            full-path = path.join{@path, key}
            match @data[key]:
               .file ->
                  expr-value @data[key] =
                     match @[DIRECTORY]:
                        undefined? -> File{full-path}
                        dir -> dir.acquire{File{full-path}}
               .directory ->
                  expr-value @data[key] =
                     match @[DIRECTORY]:
                        undefined? -> Directory{full-path}
                        dir -> dir.acquire{Directory{full-path}}
               .unsupported ->
                  throw E.unsupported-file{full-path}
               undefined? ->
                  throw E.not-found{'{@path}/{key}'}
               x ->
                  x
         {base, *rest} ->
            @get{base}.get{rest.join{"/"}}

   set{String? key or Number? key, value} =
      @data[key] = value

   .delete{key} =
      delete @data[key]

   .keys{} =
      keys{@data}

   entries{} =
      keys{@data} each k -> {k, @get{k}}

   gen [^Symbol.iterator]{} =
      keys{@data} each k -> yield @get{k}

   [^methods.proxy]{tracks, patch, prevent-dirty-reads} =
      DirectoryProxy{@path, @, tracks, patch, prevent-dirty-reads}

   [^methods.iterate-properties]{} =
      Object.prototype[methods.iterate-properties].call{@data, @}

   [^methods.fork]{} =
      rval = Object.create{Directory.prototype}
      rval.path = @path
      rval.data = {=}
      items{@data} each {key, value} ->
         rval.data[key] = value
      rval

   [^methods.patch]{patch, dir} =
      Object.prototype[methods.patch].call{@data, patch, dir, @}

   [^methods.clobber]{new-dict, dir} =
      throw E.no-clobber{"Cannot clobber a Directory object."}

   gen [^methods.relevant-changes]{reads, writes} =
      items{reads or {=}} each {match name, entry} ->
         R"^@:(.*)"! {_, minimatch.make-re! x} ->
            items{writes or {=}} each {wname, _} when x? wname ->
               yield entry
         else ->
            pass
      items{writes or {=}} each match {name, cmd} ->
         when reads[name] ->
            yield reads[name]
         when cmd.type === .directory and reads["@directories"] ->
            yield reads["@directories"]
         when reads["@iter"] ->
            yield reads["@iter"]

   [^methods.enter]{dir} =
      s = dir[fields.associated-state]
      prox = s.model{@}
      @_watcher = chokidar.watch{@path, depth = 0, ignore-initial = true}.on{.all} with
         {match event, p >> path.relative{@path, p}} ->
            .add ->
               s.transact with -> prox.set{p, "file"}
            .add-dir ->
               s.transact with -> prox.set{p, "directory"}
            .unlink ->
               s.transact with -> prox.delete{p}
            .unlink-dir when p === "" ->
               @_watcher.unwatch{@path}
            .unlink-dir ->
               s.transact with -> prox.delete{p}
            .change ->
               pass
            else ->
               print 'Untracked event: dir::{event}'

   [^methods.exit]{dir} =
      if @_watcher:
         @_watcher.unwatch{@path}



class DirectoryProxy < Directory:
   type = .directory

   constructor{@path, obj, tracks, patch, prevent-dirty-reads = true} =
      setup-proxy{@, obj, tracks, patch, prevent-dirty-reads}

   _prox{x} =
      proxy{x, @[fields.tracks], @[fields.patch], @[fields.prevent-dirty-reads]}

   find{glob} =
      gen g{} =
         match glob.split{"/"}:
            {""} ->
               yield [@]
            {"**", *rest} ->
               yield all @find{rest.join{"/"}}
               @[methods.register-tracks]{"@directories", -> true}
               [@[fields.obj]] each entry when entry.find ->
                  yield all @_prox{entry}.find{glob}
            {orig and minimatch.make-re! x, *rest} ->
               @[methods.register-tracks]{'@:{orig}', -> true}
               @[fields.obj].keys{} each
                  x? name ->
                     entry = @get{name}
                     if rest == {}:
                        yield entry
                     elif entry.type === "directory":
                        yield all entry.find{rest.join{"/"}}
                  else ->
                     continue
      FileIterator{g{}}

   get{key} =
      @[methods.check-dirty-read]{key}
      @[methods.register-tracks]{key, -> true}
      @_prox{@[fields.obj].get{key}}

   set{key, value} =
      @[methods.register-patch]{key, -> #update{deprox{value}} &: {type = value}}

   .delete{key} =
      data = @[fields.obj].data[key]
      type = if{String? data, data, data.type}
      @[methods.register-patch]{key, -> #delete{} &: {type = type}}

   gen [^Symbol.iterator]{} =
      @entries{} each {_, v} -> yield v

   keys{} =
      @[methods.register-tracks]{"@iter", -> true}
      @[fields.obj].keys{}

   entries{} =
      @[methods.register-tracks]{"@iter", -> true}
      @[fields.obj].entries{} each {k, v} ->
         {k, proxy{v
                   @[fields.tracks]
                   @[fields.patch]
                   @[fields.prevent-dirty-reads]}}

