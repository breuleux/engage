
require:
   path
   quasar ->
      cached-function
   chalk

provide:
   rename, Renamer
   task-function
   EngageMessage
   Logger


;;;;;;;;;;;;;
;; RENAMER ;;
;;;;;;;;;;;;;

rename{arg and [var {path => p} or p], opts = {=}} =
   rebase = opts.rebase or [opts.from and {opts.from => opts.to or ""}] or {=}
   items{rebase} each {from, to} ->
      rel = path.relative{from, p}
      if not rel.starts-with{"../"}:
         p = path.join{to, rel}
         break
   if opts.extension:
      p = p.replace{R"\.[a-zA-Z0-9]+$", opts.extension}
   match arg:
      String? -> p
      else -> arg.root{}.get{p}

class _Renamer:
   constructor{@options = {=}} =
      pass
   .rename{p, options = {=}} =
      rename{p, @options & options}

Renamer{options} =
   r = _Renamer{options}
   r.rename.bind{r}



;;;;;;;;;;;;;
;; LOGGING ;;
;;;;;;;;;;;;;

class EngageMessage:
   constructor{@type, @task-name, @arguments} =
      pass
   to-string{} =
      '{chalk.cyan{@type}} {@task-name}'
   inspect{} =
      '{chalk.cyan{@type}} {@task-name}'

;;;;;;;;;;;;
;; LOGGER ;;
;;;;;;;;;;;;

class Logger:
   constructor{@log-tasks = true} =
      @indent = 0
   write-line{x} =
      print [1 .. @indent each i -> ""].join{" "} + String{x}
   _log{match message} =
      EngageMessage? {type => match} ->
         when not @log-tasks ->
            @write-line{message}
         .end ->
            @indent -= 2
            @write-line{message}
         else ->
            @write-line{message}
            @indent += 2
      else ->
         @write-line{message}

Object.define-property{Logger.prototype, .log} with {
   method get{} = @_log.bind{@}
}

;;;;;;;;;;;;;;;;
;; TASK CACHE ;;
;;;;;;;;;;;;;;;;

task-cache = {=}

task-function{*match} =
   {String? name, fn} ->
      _task-function{fn, null, name}
   {fn} ->
      _task-function{fn, null, ""}

_task-function{f, transform = null, name = ""} =
   eager-async f2{*args} =
      this.log{EngageMessage{"begin", name, args}}
      await f.apply{this, args}
      this.log{EngageMessage{"end", name, args}}
      ;; try:
      ;;    await f.apply{this, args}
      ;; catch e:
      ;;    e
   m = [task-cache[f.to-string{}] or= new Map{}]
   match m.get{transform}:
      undefined? and match is transform ->
         null? ->
            c = cached-function{f2}
            m.set{transform, c}
            c
         else ->
            c = cached-function{transform{f2}}
            m.set{transform, c}
            c
      task-f ->
         task-f

