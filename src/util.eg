
require:
   path
   quasar ->
      cached-function
   chalk

provide:
   rename, Renamer
   task-function
   EngageMessage
   ;; ErrorMessage
   Logger


;;;;;;;;;;;;;
;; RENAMER ;;
;;;;;;;;;;;;;

rename{arg and [var {path => p} or p], opts = {=}} =
   rebase = opts.rebase or [opts.from and {opts.from => opts.to or ""}] or {=}
   items{rebase} each {from, to} ->
      rel = path.relative{from, p}
      if not rel.starts-with{"../"}:
         p = path.join{to, rel}
         break
   if opts.extension:
      p = p.replace{R"\.[a-zA-Z0-9]+$", opts.extension}
   match arg:
      String? -> p
      else -> arg.root{}.get{p}

class _Renamer:
   constructor{@options = {=}} =
      pass
   .rename{p, options = {=}} =
      rename{p, @options & options}

Renamer{options} =
   r = _Renamer{options}
   r.rename.bind{r}



;;;;;;;;;;;;;
;; LOGGING ;;
;;;;;;;;;;;;;

class EngageMessage:
   constructor{@type, *[@arguments]} =
      pass
   to-string{} =
      match @type:
         .begin or .end ->
            {task-name, _, time = ""} = @arguments
            xs = {
               chalk.cyan{@type}
               chalk.yellow{task-name}
               chalk.grey{if{Number? time, String{time} + "ms", ""}}
            }
            [xs each x when x -> x].join{" "}
         .error ->
            {error} = @arguments
            chalk.red{'ERROR: {error.message}'}
         .add-file ->
            chalk.green{'+ {@arguments[0]}'}
         .remove-file ->
            chalk.red{'- {@arguments[0]}'}
         .change-file ->
            chalk.yellow{'M {@arguments[0]}'}
         else ->
            '{@type}({@arguments.join{", "}})'
   inspect{} =
      @to-string{}

;; class ErrorMessage < EngageMessage:
;;    constructor{@error} =
;;       pass
;;    to-string{} =
;;       chalk.red{'ERROR: {@error.message}'}

class _Logger:
   constructor{@log-tasks = true} =
      @indent = 0
      @newline = true
   write{String! x} =
      if @newline:
         process.stdout.write{[1 .. @indent each i -> ""].join{" "}}
      process.stdout.write{x}
      @newline = true ;;x.ends-with{"\n"}
   write-line{String! x} =
      @write{x + "\n"}
   log{match message} =
      EngageMessage? {type => match} ->
         when not @log-tasks ->
            pass
         .begin ->
            @write-line{message}
            @indent += 2
         .end ->
            @indent -= 2
            @write-line{message}
         else ->
            @write-line{message}
      else ->
         @write-line{message}

Logger{*args} =
   l = _Logger{*args}
   l.log.bind{l} &: {without-newline{x} = l.write{x}}


;;;;;;;;;;;;;;;;
;; TASK CACHE ;;
;;;;;;;;;;;;;;;;

task-cache = {=}

task-function{*match} =
   {String? name, fn} ->
      _task-function{fn, null, name}
   {fn} ->
      _task-function{fn, null, ""}

_task-function{f, transform = null, name = ""} =
   eager-async f2{*args} =
      this.log{EngageMessage{"begin", name, args}}
      start-time = new Date{}.value-of{}
      try:
         result = await f.apply{this, args}
      catch e:
         if not e._engage-logged:
            this.log{EngageMessage{.error, e}}
            e._engage-logged = true
         throw e
      finally:
         end-time = new Date{}.value-of{}
         this.log{EngageMessage{"end", name, args, end-time - start-time}}
         result

         ;; try:
         ;;    await f.apply{this, args}
         ;; catch e:
         ;;    e
   m = [task-cache[f.to-string{}] or= new Map{}]
   match m.get{transform}:
      undefined? and match is transform ->
         null? ->
            c = cached-function{f2}
            m.set{transform, c}
            c
         else ->
            c = cached-function{transform{f2}}
            m.set{transform, c}
            c
      task-f ->
         task-f

